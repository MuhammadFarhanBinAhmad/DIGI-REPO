// CS2125 11/30
// dude-mi.cpp
// -- allocating/deallocating dudes from Dude multiple inheritance hierarchy
// the code here shows that the diamond problem prevents a base-class
// pointer from pointing to a derived-class object because the base-class
// object is replicated in both paths between base class Dude and
// derived class OddDude.

#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <memory>
#include "dude.hpp"

// The hierarchy described in dude.hpp includes the inheritance of 
// classes SubDude and BadDude by derived class OddDude. Classes SubDude 
// and BadDude are inherited from the same base class Dude. This means that
// there is more than one path between a base class (Dude) and a derived
// class (OddDude): the first path is through class SubDude and the second
// path is through class BadDude. Because of these two paths, base class 
// Dude will be replicated twice when an object of type OddDude is instantiated. 
// For this reason, we can't make use of the C++ rule that a base-class pointer
// can point to a derived-class object. On the positive side, run-time 
// polymorphism is unaffected for the portion of the hierarchy that is not 
// based on MI. Note that we can instantiate objects of type OddDude - we just
// can't use a Dude* to point to these instantiated objects.

int main() {
  // Dude class hierarchy uses pseudo-random numbers generated by
  // standard library - therefore, make sure to set the generator's seed
  srand(unsigned(time(0)));

  std::vector<std::unique_ptr<Dude>> dudes;
  dudes.emplace_back(std::make_unique<Dude>("D"));
  dudes.emplace_back(std::make_unique<SubDude>("S"));
  dudes.emplace_back(std::make_unique<BadDude>("B"));
  dudes.emplace_back(std::make_unique<MajorDude>("M"));
  dudes.emplace_back(std::make_unique<GodDude>("G"));

  // We've a MI hierarchy with more than one path between a base class (Dude)
  // and a derived class (OddDude): the first path is through class SubDude and
  // the second path is through class BadDude.
  // Because of these two paths, base class Dude will be replicated when an
  // object of type OddDude is instantiated.
  // For this reason, we can't make use of the C++ rule that a base-class
  // pointer can point to a derived-class object.
  //dudes.emplace_back(std::make_unique<OddDude>("O"));  // Ambiguous. Which Dude? SubDude::Dude or BadDude::Dude?
  
  // Note that we can create an object of type OddDude
  OddDude o("O");
  // or make an OddDude pointer point to a heap-based OddDude:
  std::unique_ptr<OddDude> upo = std::make_unique<OddDude>("OO");
  std::unique_ptr<SubDude> uso = std::make_unique<OddDude>("OOO");
  // we just can't make base class pointer of type Dude* point to a OddDude object.
  //dudes.emplace_back(std::make_unique<OddDude>("OOO"));
  
  for (std::unique_ptr<Dude> const& pd : dudes) {
    std::cout << pd->name() << " punch: ";
    if (pd->punch()) {
      std::cout << "hits\n";
    } else {
      std::cout << "misses\n";
    }
  }
}
