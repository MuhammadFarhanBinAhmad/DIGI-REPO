// HLP3: player.cpp [with raw pointers]
// 11/05/2023
// You call a virtual function to achieve type-specific behavior when you've a
// pointer or reference to an object but you don't know what the real type of
// the object is. For example:
// IWeapon *pw = make_weapon(); // pw could be pointing to a Knife, Dagger, or Sword object
// pw->print();
//
// You call a constructor only when you don't yet have an object but you know
// exactly what type you'd like to have.
// IWeapon *pw = new Dagger{"dagger", 3}; // construct an object of type Dagger ...
//
// The make_weapon() function creates new objects and therefore acts like a ctor.
// But because it can create different types of objects, it is called a
// virtual constructor.
// A virtual constructor is a function that creates different types of objects
// depending on the input it is given. It is particularly useful when programs
// need to create user-defined objects before manipulating them. A good example is a
// game engine that needs to create a level from the information generated by a
// level-editor that was stored to disk.

// Thus,
// class ObjectManager {
//   ...
// public:
//   Object* new_object();
// private:
//   virtual Object* create_object() = 0; // factory method
//   std::list<Object*> list_of_objs;
// };
//
// The actual type of each object in the level was stored in the form of a string, 
// an integral value, an identifier of some sort. Thus, although the type information
// exists, its form doesn't allow new_object to create C++ objects using new. Instead,
// pure virtual function create_object replaces a call to new. new_object cannot use
// the new operator because the concrete object to be created is not known by the time 
// ObjectManager is written.
// Object* ObjectManager::new_object() {
//   Object *ptr_obj = create_object();
//   list_of_objs.push_back(ptr_obj);
//   ...
//   return ptr_obj;
// }
//
// Because the derived class knows exactly the type of object to be created, it can invoke
// the new operator directly. This way, you can remove the type information from the
// framework and have the framework operate on the base class Object only:
// Object* EnemyObjectManager::create_object() {
//   return new EnemyObject;
// }
// ot only need to manipulate user-defined objects but also create themunsearializing
#include <iostream>
#include <string>

class IWeapon {
protected:
  IWeapon(std::string const& rhs) : n{rhs} {}
  IWeapon(IWeapon const& rhs) : n{rhs.n} {}
  IWeapon& operator=(IWeapon const& rhs) { n = rhs.n; return *this; }
public:
  virtual ~IWeapon() { std::cout << __PRETTY_FUNCTION__ << '\n'; }
  virtual IWeapon* clone() const = 0;
  virtual void print() const = 0;
  virtual void slash() = 0;
  virtual void burn() = 0;
private:
  std::string n;
};
void IWeapon::print() const { std::cout << n << ' '; }

class Knife : public IWeapon {
public:
  Knife(std::string const& n, int len) : IWeapon{n}, length{len} {}
  Knife(Knife const& rhs) : IWeapon{rhs}, length{rhs.length} {}
  ~Knife() { std::cout << __PRETTY_FUNCTION__ << '\n'; }
  Knife* clone() const override { return new Knife{*this}; }
  void print() const override { IWeapon::print(); std::cout << length << '\n'; }
  void slash() override { std::cout << __PRETTY_FUNCTION__ << "\n"; }
  void burn() override { std::cout << __PRETTY_FUNCTION__ << "\n"; }
private:
  int length;
};

class Dagger : public IWeapon {
public:
  Dagger(std::string const& n, double d) : IWeapon{n}, depth{d} {}
  Dagger(Dagger const& rhs) : IWeapon{rhs}, depth{rhs.depth} {}
  ~Dagger() { std::cout << __PRETTY_FUNCTION__ << '\n'; }
  Dagger* clone() const override { return new Dagger{*this}; }
  void print() const override { IWeapon::print(); std::cout << depth << '\n'; }
  void slash() override { std::cout << __PRETTY_FUNCTION__ << "\n"; }
  void burn() override { std::cout << __PRETTY_FUNCTION__ << "\n"; }
private:
  double depth;
};

class Sword : public IWeapon {
public:
  Sword(std::string const& n, int len, double d) : IWeapon{n}, length{len}, depth{d} {}
  Sword(Sword const& rhs) : IWeapon{rhs}, length{rhs.length}, depth{rhs.depth} {}
  ~Sword() { std::cout << __PRETTY_FUNCTION__ << '\n'; }
  Sword* clone() const override { return new Sword{*this}; }
  void print() const override {  IWeapon::print(); std::cout << length << ' ' << depth << '\n'; }
  void slash() override { std::cout << __PRETTY_FUNCTION__ << "\n"; }
  void burn() override { std::cout << __PRETTY_FUNCTION__ << "\n"; }
private:
  int length;
  double depth;
};

// the virtual constructor ...
IWeapon* make_weapon(int type) {
  switch (type) {
    case 1: return new Knife{"knife", 33};
    case 2: return new Dagger{"dagger", 3.14};
    case 3: return new Sword{"sword", 33, 3.14};
    default: return new Knife{"knife", 44};
  }
}

// Dependency Inversion Principle [Robert Martin]:
// High-level modules should not depend on low-level modules and vice-versa.
// Both should be separated by interfaces.
class Player {
public:
  Player(int type) : pw{make_weapon(type)} {} // using dependency injection pattern ...
  ~Player() { delete pw; std::cout << __PRETTY_FUNCTION__ << '\n'; }
  Player(Player const& rhs) : pw{rhs.pw->clone()} {}
  Player& operator=(Player const& rhs) { Player tmp{rhs}; std::swap(tmp.pw, pw); return *this; }
  void play() const { pw->slash(); pw->burn(); pw->print(); }
  void change_weapon(int type) {
    IWeapon *pw_copy = make_weapon(type);
    delete pw;
    pw = pw_copy;
  }
private:
  IWeapon *pw; // use of dependency injection pattern ...
};

int main() {
  Player toad{3};
  toad.play();
  toad.change_weapon(1);
  toad.play();
  std::cout << "-------------------------------------------------\n";
  Player toad2{toad};
  toad2.play();
  std::cout << "-------------------------------------------------\n";
  Player toad3{2};
  toad3.play();
  toad3 = toad2;
  toad3.play();
  std::cout << "-------------------------------------------------\n";
}
