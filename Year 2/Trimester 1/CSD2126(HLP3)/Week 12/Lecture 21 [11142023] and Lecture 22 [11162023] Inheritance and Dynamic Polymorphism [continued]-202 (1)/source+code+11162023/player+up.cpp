// HLP3: Player+up.cpp [with std::unique_ptr]
// 11/05/2023
// You call a virtual function to achieve type-specific behavior when you've a
// pointer or reference to an object but you don't know what the real type of
// the object is. For example:
// IWeapon *pw = get_weapon(); // pw could be pointing to a Knife, Dagger, or Sword object
// pw->print();
//
// You call a constructor only when you don't yet have an object but you know
// exactly what type you'd like to have.
// IWeapon *pw = new Dagger{"dagger", 3}; // construct an object of type Dagger ...
//
// The make_weapon() function creates new objects and therefore acts like a ctor.
// But because it can create different types of objects, it is called a
// virtual constructor.
// A virtual constructor is a function that creates different types of objects
// depending on the input it is given. It is particularly useful when programs
// need to create user-defined objects before manipulating them. A good example is a
// game engine that needs to create a level from the information generated by a
// level-editor that was stored to disk.
// The virtual copy constructor is the most widely used virtual constructor.
// A virtual copy ctor returns a pointer to a new copy of the object invoking
// the function and because of this behavior is generally named clone.

#include <iostream>
#include <string>
#include <memory>

class IWeapon {
protected:
  IWeapon(std::string const& rhs) : n{rhs} {}
  IWeapon(IWeapon const& rhs) : n{rhs.n} {}
  IWeapon& operator=(IWeapon const& rhs) { n = rhs.n; return *this; }
public:
  virtual ~IWeapon() { std::cout << __PRETTY_FUNCTION__ << '\n'; }
  virtual std::unique_ptr<IWeapon> clone() const = 0;
  virtual std::ostream& print(std::ostream&) const = 0;
  virtual void slash() = 0;
  virtual void burn() = 0;
private:
  std::string n;
};

std::ostream& IWeapon::print(std::ostream& os) const { return os << n << ' '; }

class Knife : public IWeapon {
public:
  Knife(std::string const& n, int len) : IWeapon{n}, length{len} {}
  Knife(Knife const& rhs) : IWeapon{rhs}, length{rhs.length} {}
  virtual ~Knife() { std::cout << __PRETTY_FUNCTION__ << '\n'; }
  virtual std::unique_ptr<IWeapon> clone() const override { return std::make_unique<Knife>(*this); }
  virtual std::ostream& print(std::ostream& os) const override { 
    IWeapon::print(os); 
    return os << length << '\n';
  }
  void slash() override { std::cout << __PRETTY_FUNCTION__ << "\n"; }
  void burn() override { std::cout << __PRETTY_FUNCTION__ << "\n"; }
private:
  int length;
};

class Dagger : public IWeapon {
public:
  Dagger(std::string const& n, double d) : IWeapon{n}, depth{d} {}
  Dagger(Dagger const& rhs) : IWeapon{rhs}, depth{rhs.depth} {}
  virtual ~Dagger() { std::cout << __PRETTY_FUNCTION__ << '\n'; }
  virtual std::unique_ptr<IWeapon> clone() const override { return std::make_unique<Dagger>(*this); }
  virtual std::ostream& print(std::ostream& os) const override {
    IWeapon::print(os);
    return os << depth << '\n';
  }
  void slash() override { std::cout << __PRETTY_FUNCTION__ << "\n"; }
  void burn() override { std::cout << __PRETTY_FUNCTION__ << "\n"; }
private:
  double depth;
};

class Sword : public IWeapon {
public:
  Sword(std::string const& n, int len, double d) : IWeapon{n}, length{len}, depth{d} {}
  Sword(Sword const& rhs) : IWeapon{rhs}, length{rhs.length}, depth{rhs.depth} {}
  virtual ~Sword() { std::cout << __PRETTY_FUNCTION__ << '\n'; }
  virtual std::unique_ptr<IWeapon> clone() const override { return std::make_unique<Sword>(*this); }
  virtual std::ostream& print(std::ostream& os) const override {
    IWeapon::print(os);
    return os << length << ' ' << depth << '\n';
  }
  void slash() override { std::cout << __PRETTY_FUNCTION__ << "\n"; }
  void burn() override { std::cout << __PRETTY_FUNCTION__ << "\n"; }
private:
  int length;
  double depth;
};

std::ostream& operator<<(std::ostream& os, IWeapon const& rhs) {
  return rhs.print(os);
}

std::unique_ptr<IWeapon> make_weapon(int type) {
  switch (type) {
    case 1: return std::make_unique<Knife>("knife", 33);
    case 2: return std::make_unique<Dagger>("dagger", 3.14);
    case 3: return std::make_unique<Sword>("sword", 33, 3.14);
    default: return std::make_unique<Knife>("knife", 33);
  }
}

class Player {
public:
  Player(std::unique_ptr<IWeapon> rhs) : pw{std::move(rhs)} {}
  ~Player() { /*delete pw;*/ std::cout << __PRETTY_FUNCTION__ << '\n'; }
  // using virtual copy ctor to implement Player's copy ctor
  Player(Player const& rhs) : pw{rhs.pw->clone()} {}
  // using virtual copy ctor to implement Player's copy assignment
  Player& operator=(Player const& rhs) {
    Player tmp{rhs};    // copy
    std::swap(tmp.pw, pw); // swap
    return *this;
  }
  void play() const { pw->slash(); pw->burn(); }
  void change_weapon(int type) {
    std::unique_ptr<IWeapon> pw_copy = make_weapon(type);
    pw.swap(pw_copy);
  }
private:
  std::unique_ptr<IWeapon> pw;
};

int main() {
  Player toad{make_weapon(2)};
  toad.play();
  toad.change_weapon(1);
  toad.play();
std::cout << "-------------------------------------------------\n"; 
  Player toad2{toad};
  toad2.play();
  std::cout << "-------------------------------------------------\n";
  Player toad3{make_weapon(1)};
  toad3.play();
  toad3 = toad2;
  toad3.play();
  std::cout << "-------------------------------------------------\n";
}